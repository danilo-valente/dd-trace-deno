import { storage } from '../../../../../datadog-core/index.ts';
import { getFirstNonDDPathAndLine } from '../path-line.ts';
import { addVulnerability } from '../vulnerability-reporter.ts';
import { getIastContext } from '../iast-context.ts';
import overheadController from './overhead-controller.ts';
import { SinkIastPlugin } from '../iast-plugin.ts';
import { getOriginalPathAndLineFromSourceMap } from '../taint-tracking/rewriter.ts';

class Analyzer extends SinkIastPlugin {
  private _type: any;

  constructor(type) {
    super();
    this._type = type;
  }

  _isVulnerable(value, context: { [x: string]: any[]; rootSpan: any }) {
    return false;
  }

  _isExcluded(location: { path: any; line: any; column: any; isInternal: boolean }) {
    return false;
  }

  _report(value, context: { [x: string]: any[]; rootSpan: any }) {
    const evidence = this._getEvidence(value, context);

    const location = this._getLocation(value);
    if (!this._isExcluded(location)) {
      const locationSourceMap = this._replaceLocationFromSourceMap(location);
      const spanId = context && context.rootSpan && context.rootSpan.context().toSpanId();
      const vulnerability = this._createVulnerability(this._type, evidence, spanId, locationSourceMap);
      addVulnerability(context, vulnerability);
    }
  }

  _reportIfVulnerable(value, context: { [x: string]: any[]; rootSpan: any }) {
    if (this._isVulnerable(value, context) && this._checkOCE(context, value)) {
      this._report(value, context);
      return true;
    }
    return false;
  }

  _getEvidence(value) {
    return { value };
  }

  _getLocation() {
    return getFirstNonDDPathAndLine(this._getExcludedPaths());
  }

  _replaceLocationFromSourceMap(location: { path: any; line: any; column: any; isInternal?: boolean }) {
    if (location) {
      const { path, line, column } = getOriginalPathAndLineFromSourceMap(location);
      if (path) {
        location.path = path;
      }
      if (line) {
        location.line = line;
      }
      if (column) {
        location.column = column;
      }
    }
    return location;
  }

  _getExcludedPaths() {}

  _isInvalidContext(store, iastContext) {
    return store && !iastContext;
  }

  analyze(value) {
    const store = storage.getStore();
    const iastContext = getIastContext(store);
    if (this._isInvalidContext(store, iastContext)) return;

    this._reportIfVulnerable(value, iastContext);
  }

  analyzeAll(...values) {
    const store = storage.getStore();
    const iastContext = getIastContext(store);
    if (this._isInvalidContext(store, iastContext)) return;

    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      if (this._isVulnerable(value, iastContext)) {
        if (this._checkOCE(iastContext, value)) {
          this._report(value, iastContext);
        }
        break;
      }
    }
  }

  _checkOCE(context: { [x: string]: any[]; rootSpan: any }) {
    return overheadController.hasQuota(overheadController.OPERATIONS.REPORT_VULNERABILITY, context);
  }

  _createVulnerability(
    type,
    evidence: { value: any },
    spanId: number,
    location: { path: any; line: any; column?: any; isInternal?: boolean },
  ) {
    if (type && evidence) {
      const _spanId = spanId || 0;
      return {
        type,
        evidence,
        location: {
          spanId: _spanId,
          ...location,
        },
        hash: this._createHash(this._createHashSource(type, evidence, location)),
      };
    }
    return null;
  }

  _createHashSource(type, evidence: { value: any }, location: { path: any; line: any }) {
    return location ? `${type}:${location.path}:${location.line}` : type;
  }

  _createHash(hashSource: string) {
    let hash = 0;
    let offset = 0;
    const size = hashSource.length;
    for (let i = 0; i < size; i++) {
      hash = ((hash << 5) - hash) + hashSource.charCodeAt(offset++);
    }
    return hash;
  }

  addSub(
    iastSubOrChannelName: { channelName: string; tag: any },
    handler: {
      ({ req }: { req: any }): void;
      ({ qs }: { qs: any }): void;
      ({ req }: { req: any }): void;
      ({ cookies }: { cookies: any }): void;
      ({ req }: { req: any }): void;
    },
  ) {
    const iastSub = typeof iastSubOrChannelName === 'string'
      ? { channelName: iastSubOrChannelName }
      : iastSubOrChannelName;

    super.addSub({ tag: this._type, ...iastSub }, handler);
  }
}

export default Analyzer;
