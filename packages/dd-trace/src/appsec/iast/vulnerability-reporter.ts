import * as tags from 'npm:dd-trace@4.13.1/ext/tags.js';
const { MANUAL_KEEP } = tags;
import LRU from 'npm:lru-cache@7.14.0';
import vulnerabilitiesFormatter from './vulnerabilities-formatter/index.ts';
import { IAST_ENABLED_TAG_KEY, IAST_JSON_TAG_KEY } from './tags.ts';

const VULNERABILITIES_KEY = 'vulnerabilities';
const VULNERABILITY_HASHES_MAX_SIZE = 1000;
const VULNERABILITY_HASHES = new LRU({ max: VULNERABILITY_HASHES_MAX_SIZE });
const RESET_VULNERABILITY_CACHE_INTERVAL = 60 * 60 * 1000; // 1 hour

let tracer;
let resetVulnerabilityCacheTimer;
let deduplicationEnabled = true;

function addVulnerability(
  iastContext:
    | { [x: string]: any[]; rootSpan: any }
    | ({ rootSpan: { context: () => { (): any; new (): any; toSpanId: { (): any; new (): any } } } }),
  vulnerability: { type: any; evidence: any; location: any; hash?: number },
) {
  if (
    vulnerability && vulnerability.evidence && vulnerability.type &&
    vulnerability.location
  ) {
    if (iastContext && iastContext.rootSpan) {
      iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || [];
      iastContext[VULNERABILITIES_KEY].push(vulnerability);
    } else {
      sendVulnerabilities([vulnerability]);
    }
  }
}

function isValidVulnerability(vulnerability: { type: any; evidence: any; location: { spanId: any } }) {
  return vulnerability && vulnerability.type &&
    vulnerability.evidence &&
    vulnerability.location && vulnerability.location.spanId;
}

function sendVulnerabilities(vulnerabilities: any[], rootSpan: undefined) {
  if (vulnerabilities && vulnerabilities.length) {
    let span = rootSpan;
    if (!span && tracer) {
      span = tracer.startSpan('vulnerability', {
        type: 'vulnerability',
      });
      vulnerabilities.forEach((vulnerability: { location: { spanId: any } }) => {
        vulnerability.location.spanId = span.context().toSpanId();
      });
      span.addTags({
        [IAST_ENABLED_TAG_KEY]: 1,
      });
    }

    if (span && span.addTags) {
      const validAndDedupVulnerabilities = deduplicateVulnerabilities(vulnerabilities).filter(isValidVulnerability);
      const jsonToSend = vulnerabilitiesFormatter.toJson(validAndDedupVulnerabilities);

      if (jsonToSend.vulnerabilities.length > 0) {
        const tags = {};
        // TODO: Store this outside of the span and set the tag in the exporter.
        tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend);
        tags[MANUAL_KEEP] = 'true';
        span.addTags(tags);
        if (!rootSpan) span.finish();
      }
    }
  }
  return IAST_JSON_TAG_KEY;
}

function clearCache() { // only for test purposes
  VULNERABILITY_HASHES.clear();
}

function startClearCacheTimer() {
  resetVulnerabilityCacheTimer = setInterval(clearCache, RESET_VULNERABILITY_CACHE_INTERVAL);
  resetVulnerabilityCacheTimer.unref();
}

function stopClearCacheTimer() {
  if (resetVulnerabilityCacheTimer) {
    clearInterval(resetVulnerabilityCacheTimer);
    resetVulnerabilityCacheTimer = null;
  }
}

function deduplicateVulnerabilities(vulnerabilities: any[]) {
  if (!deduplicationEnabled) return vulnerabilities;
  const deduplicated = vulnerabilities.filter((vulnerability: { type: any; hash: any }) => {
    const key = `${vulnerability.type}${vulnerability.hash}`;
    if (!VULNERABILITY_HASHES.get(key)) {
      VULNERABILITY_HASHES.set(key, true);
      return true;
    }
    return false;
  });
  return deduplicated;
}

function start(config: { iast: { deduplicationEnabled: boolean; redactionEnabled: any } }, _tracer) {
  deduplicationEnabled = config.iast.deduplicationEnabled;
  vulnerabilitiesFormatter.setRedactVulnerabilities(config.iast.redactionEnabled);
  if (deduplicationEnabled) {
    startClearCacheTimer();
  }
  tracer = _tracer;
}

function stop() {
  stopClearCacheTimer();
}

export { addVulnerability, clearCache, sendVulnerabilities, start, stop };
